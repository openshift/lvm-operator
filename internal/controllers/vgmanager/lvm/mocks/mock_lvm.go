// Code generated by mockery v2.43.2. DO NOT EDIT.

package lvm

import (
	context "context"

	lvm "github.com/openshift/lvm-operator/v4/internal/controllers/vgmanager/lvm"
	mock "github.com/stretchr/testify/mock"
)

// MockLVM is an autogenerated mock type for the LVM type
type MockLVM struct {
	mock.Mock
}

type MockLVM_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLVM) EXPECT() *MockLVM_Expecter {
	return &MockLVM_Expecter{mock: &_m.Mock}
}

// ActivateLV provides a mock function with given fields: ctx, lvName, vgName
func (_m *MockLVM) ActivateLV(ctx context.Context, lvName string, vgName string) error {
	ret := _m.Called(ctx, lvName, vgName)

	if len(ret) == 0 {
		panic("no return value specified for ActivateLV")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, lvName, vgName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLVM_ActivateLV_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ActivateLV'
type MockLVM_ActivateLV_Call struct {
	*mock.Call
}

// ActivateLV is a helper method to define mock.On call
//   - ctx context.Context
//   - lvName string
//   - vgName string
func (_e *MockLVM_Expecter) ActivateLV(ctx interface{}, lvName interface{}, vgName interface{}) *MockLVM_ActivateLV_Call {
	return &MockLVM_ActivateLV_Call{Call: _e.mock.On("ActivateLV", ctx, lvName, vgName)}
}

func (_c *MockLVM_ActivateLV_Call) Run(run func(ctx context.Context, lvName string, vgName string)) *MockLVM_ActivateLV_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockLVM_ActivateLV_Call) Return(_a0 error) *MockLVM_ActivateLV_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLVM_ActivateLV_Call) RunAndReturn(run func(context.Context, string, string) error) *MockLVM_ActivateLV_Call {
	_c.Call.Return(run)
	return _c
}

// AddTagToVG provides a mock function with given fields: ctx, vgName
func (_m *MockLVM) AddTagToVG(ctx context.Context, vgName string) error {
	ret := _m.Called(ctx, vgName)

	if len(ret) == 0 {
		panic("no return value specified for AddTagToVG")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, vgName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLVM_AddTagToVG_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddTagToVG'
type MockLVM_AddTagToVG_Call struct {
	*mock.Call
}

// AddTagToVG is a helper method to define mock.On call
//   - ctx context.Context
//   - vgName string
func (_e *MockLVM_Expecter) AddTagToVG(ctx interface{}, vgName interface{}) *MockLVM_AddTagToVG_Call {
	return &MockLVM_AddTagToVG_Call{Call: _e.mock.On("AddTagToVG", ctx, vgName)}
}

func (_c *MockLVM_AddTagToVG_Call) Run(run func(ctx context.Context, vgName string)) *MockLVM_AddTagToVG_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLVM_AddTagToVG_Call) Return(_a0 error) *MockLVM_AddTagToVG_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLVM_AddTagToVG_Call) RunAndReturn(run func(context.Context, string) error) *MockLVM_AddTagToVG_Call {
	_c.Call.Return(run)
	return _c
}

// CreateLV provides a mock function with given fields: ctx, lvName, vgName, sizePercent, chunkSizeBytes, metadataSizeBytes
func (_m *MockLVM) CreateLV(ctx context.Context, lvName string, vgName string, sizePercent int, chunkSizeBytes int64, metadataSizeBytes int64) error {
	ret := _m.Called(ctx, lvName, vgName, sizePercent, chunkSizeBytes, metadataSizeBytes)

	if len(ret) == 0 {
		panic("no return value specified for CreateLV")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, int64, int64) error); ok {
		r0 = rf(ctx, lvName, vgName, sizePercent, chunkSizeBytes, metadataSizeBytes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLVM_CreateLV_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLV'
type MockLVM_CreateLV_Call struct {
	*mock.Call
}

// CreateLV is a helper method to define mock.On call
//   - ctx context.Context
//   - lvName string
//   - vgName string
//   - sizePercent int
//   - chunkSizeBytes int64
//   - metadataSizeBytes int64
func (_e *MockLVM_Expecter) CreateLV(ctx interface{}, lvName interface{}, vgName interface{}, sizePercent interface{}, chunkSizeBytes interface{}, metadataSizeBytes interface{}) *MockLVM_CreateLV_Call {
	return &MockLVM_CreateLV_Call{Call: _e.mock.On("CreateLV", ctx, lvName, vgName, sizePercent, chunkSizeBytes, metadataSizeBytes)}
}

func (_c *MockLVM_CreateLV_Call) Run(run func(ctx context.Context, lvName string, vgName string, sizePercent int, chunkSizeBytes int64, metadataSizeBytes int64)) *MockLVM_CreateLV_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int), args[4].(int64), args[5].(int64))
	})
	return _c
}

func (_c *MockLVM_CreateLV_Call) Return(_a0 error) *MockLVM_CreateLV_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLVM_CreateLV_Call) RunAndReturn(run func(context.Context, string, string, int, int64, int64) error) *MockLVM_CreateLV_Call {
	_c.Call.Return(run)
	return _c
}

// CreateVG provides a mock function with given fields: ctx, vg, opts
func (_m *MockLVM) CreateVG(ctx context.Context, vg lvm.VolumeGroup, opts lvm.CreateVGOptions) error {
	ret := _m.Called(ctx, vg, opts)

	if len(ret) == 0 {
		panic("no return value specified for CreateVG")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, lvm.VolumeGroup, lvm.CreateVGOptions) error); ok {
		r0 = rf(ctx, vg, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLVM_CreateVG_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateVG'
type MockLVM_CreateVG_Call struct {
	*mock.Call
}

// CreateVG is a helper method to define mock.On call
//   - ctx context.Context
//   - vg lvm.VolumeGroup
//   - opts lvm.CreateVGOptions
func (_e *MockLVM_Expecter) CreateVG(ctx interface{}, vg interface{}, opts interface{}) *MockLVM_CreateVG_Call {
	return &MockLVM_CreateVG_Call{Call: _e.mock.On("CreateVG", ctx, vg, opts)}
}

func (_c *MockLVM_CreateVG_Call) Run(run func(ctx context.Context, vg lvm.VolumeGroup, opts lvm.CreateVGOptions)) *MockLVM_CreateVG_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(lvm.VolumeGroup), args[2].(lvm.CreateVGOptions))
	})
	return _c
}

func (_c *MockLVM_CreateVG_Call) Return(_a0 error) *MockLVM_CreateVG_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLVM_CreateVG_Call) RunAndReturn(run func(context.Context, lvm.VolumeGroup, lvm.CreateVGOptions) error) *MockLVM_CreateVG_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteLV provides a mock function with given fields: ctx, lvName, vgName
func (_m *MockLVM) DeleteLV(ctx context.Context, lvName string, vgName string) error {
	ret := _m.Called(ctx, lvName, vgName)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLV")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, lvName, vgName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLVM_DeleteLV_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteLV'
type MockLVM_DeleteLV_Call struct {
	*mock.Call
}

// DeleteLV is a helper method to define mock.On call
//   - ctx context.Context
//   - lvName string
//   - vgName string
func (_e *MockLVM_Expecter) DeleteLV(ctx interface{}, lvName interface{}, vgName interface{}) *MockLVM_DeleteLV_Call {
	return &MockLVM_DeleteLV_Call{Call: _e.mock.On("DeleteLV", ctx, lvName, vgName)}
}

func (_c *MockLVM_DeleteLV_Call) Run(run func(ctx context.Context, lvName string, vgName string)) *MockLVM_DeleteLV_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockLVM_DeleteLV_Call) Return(_a0 error) *MockLVM_DeleteLV_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLVM_DeleteLV_Call) RunAndReturn(run func(context.Context, string, string) error) *MockLVM_DeleteLV_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteVG provides a mock function with given fields: ctx, vg, opts
func (_m *MockLVM) DeleteVG(ctx context.Context, vg lvm.VolumeGroup, opts lvm.DeleteVGOptions) error {
	ret := _m.Called(ctx, vg, opts)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVG")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, lvm.VolumeGroup, lvm.DeleteVGOptions) error); ok {
		r0 = rf(ctx, vg, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLVM_DeleteVG_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteVG'
type MockLVM_DeleteVG_Call struct {
	*mock.Call
}

// DeleteVG is a helper method to define mock.On call
//   - ctx context.Context
//   - vg lvm.VolumeGroup
//   - opts lvm.DeleteVGOptions
func (_e *MockLVM_Expecter) DeleteVG(ctx interface{}, vg interface{}, opts interface{}) *MockLVM_DeleteVG_Call {
	return &MockLVM_DeleteVG_Call{Call: _e.mock.On("DeleteVG", ctx, vg, opts)}
}

func (_c *MockLVM_DeleteVG_Call) Run(run func(ctx context.Context, vg lvm.VolumeGroup, opts lvm.DeleteVGOptions)) *MockLVM_DeleteVG_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(lvm.VolumeGroup), args[2].(lvm.DeleteVGOptions))
	})
	return _c
}

func (_c *MockLVM_DeleteVG_Call) Return(_a0 error) *MockLVM_DeleteVG_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLVM_DeleteVG_Call) RunAndReturn(run func(context.Context, lvm.VolumeGroup, lvm.DeleteVGOptions) error) *MockLVM_DeleteVG_Call {
	_c.Call.Return(run)
	return _c
}

// ExtendLV provides a mock function with given fields: ctx, lvName, vgName, sizePercent
func (_m *MockLVM) ExtendLV(ctx context.Context, lvName string, vgName string, sizePercent int) error {
	ret := _m.Called(ctx, lvName, vgName, sizePercent)

	if len(ret) == 0 {
		panic("no return value specified for ExtendLV")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int) error); ok {
		r0 = rf(ctx, lvName, vgName, sizePercent)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLVM_ExtendLV_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExtendLV'
type MockLVM_ExtendLV_Call struct {
	*mock.Call
}

// ExtendLV is a helper method to define mock.On call
//   - ctx context.Context
//   - lvName string
//   - vgName string
//   - sizePercent int
func (_e *MockLVM_Expecter) ExtendLV(ctx interface{}, lvName interface{}, vgName interface{}, sizePercent interface{}) *MockLVM_ExtendLV_Call {
	return &MockLVM_ExtendLV_Call{Call: _e.mock.On("ExtendLV", ctx, lvName, vgName, sizePercent)}
}

func (_c *MockLVM_ExtendLV_Call) Run(run func(ctx context.Context, lvName string, vgName string, sizePercent int)) *MockLVM_ExtendLV_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int))
	})
	return _c
}

func (_c *MockLVM_ExtendLV_Call) Return(_a0 error) *MockLVM_ExtendLV_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLVM_ExtendLV_Call) RunAndReturn(run func(context.Context, string, string, int) error) *MockLVM_ExtendLV_Call {
	_c.Call.Return(run)
	return _c
}

// ExtendThinPoolMetadata provides a mock function with given fields: ctx, lvName, vgName, metadataSizeBytes
func (_m *MockLVM) ExtendThinPoolMetadata(ctx context.Context, lvName string, vgName string, metadataSizeBytes int64) error {
	ret := _m.Called(ctx, lvName, vgName, metadataSizeBytes)

	if len(ret) == 0 {
		panic("no return value specified for ExtendThinPoolMetadata")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64) error); ok {
		r0 = rf(ctx, lvName, vgName, metadataSizeBytes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLVM_ExtendThinPoolMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExtendThinPoolMetadata'
type MockLVM_ExtendThinPoolMetadata_Call struct {
	*mock.Call
}

// ExtendThinPoolMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - lvName string
//   - vgName string
//   - metadataSizeBytes int64
func (_e *MockLVM_Expecter) ExtendThinPoolMetadata(ctx interface{}, lvName interface{}, vgName interface{}, metadataSizeBytes interface{}) *MockLVM_ExtendThinPoolMetadata_Call {
	return &MockLVM_ExtendThinPoolMetadata_Call{Call: _e.mock.On("ExtendThinPoolMetadata", ctx, lvName, vgName, metadataSizeBytes)}
}

func (_c *MockLVM_ExtendThinPoolMetadata_Call) Run(run func(ctx context.Context, lvName string, vgName string, metadataSizeBytes int64)) *MockLVM_ExtendThinPoolMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int64))
	})
	return _c
}

func (_c *MockLVM_ExtendThinPoolMetadata_Call) Return(_a0 error) *MockLVM_ExtendThinPoolMetadata_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLVM_ExtendThinPoolMetadata_Call) RunAndReturn(run func(context.Context, string, string, int64) error) *MockLVM_ExtendThinPoolMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// ExtendVG provides a mock function with given fields: ctx, vg, pvs
func (_m *MockLVM) ExtendVG(ctx context.Context, vg lvm.VolumeGroup, pvs []string) (lvm.VolumeGroup, error) {
	ret := _m.Called(ctx, vg, pvs)

	if len(ret) == 0 {
		panic("no return value specified for ExtendVG")
	}

	var r0 lvm.VolumeGroup
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, lvm.VolumeGroup, []string) (lvm.VolumeGroup, error)); ok {
		return rf(ctx, vg, pvs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, lvm.VolumeGroup, []string) lvm.VolumeGroup); ok {
		r0 = rf(ctx, vg, pvs)
	} else {
		r0 = ret.Get(0).(lvm.VolumeGroup)
	}

	if rf, ok := ret.Get(1).(func(context.Context, lvm.VolumeGroup, []string) error); ok {
		r1 = rf(ctx, vg, pvs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLVM_ExtendVG_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExtendVG'
type MockLVM_ExtendVG_Call struct {
	*mock.Call
}

// ExtendVG is a helper method to define mock.On call
//   - ctx context.Context
//   - vg lvm.VolumeGroup
//   - pvs []string
func (_e *MockLVM_Expecter) ExtendVG(ctx interface{}, vg interface{}, pvs interface{}) *MockLVM_ExtendVG_Call {
	return &MockLVM_ExtendVG_Call{Call: _e.mock.On("ExtendVG", ctx, vg, pvs)}
}

func (_c *MockLVM_ExtendVG_Call) Run(run func(ctx context.Context, vg lvm.VolumeGroup, pvs []string)) *MockLVM_ExtendVG_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(lvm.VolumeGroup), args[2].([]string))
	})
	return _c
}

func (_c *MockLVM_ExtendVG_Call) Return(_a0 lvm.VolumeGroup, _a1 error) *MockLVM_ExtendVG_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLVM_ExtendVG_Call) RunAndReturn(run func(context.Context, lvm.VolumeGroup, []string) (lvm.VolumeGroup, error)) *MockLVM_ExtendVG_Call {
	_c.Call.Return(run)
	return _c
}

// GetVG provides a mock function with given fields: ctx, name
func (_m *MockLVM) GetVG(ctx context.Context, name string) (lvm.VolumeGroup, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for GetVG")
	}

	var r0 lvm.VolumeGroup
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (lvm.VolumeGroup, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) lvm.VolumeGroup); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Get(0).(lvm.VolumeGroup)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLVM_GetVG_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVG'
type MockLVM_GetVG_Call struct {
	*mock.Call
}

// GetVG is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockLVM_Expecter) GetVG(ctx interface{}, name interface{}) *MockLVM_GetVG_Call {
	return &MockLVM_GetVG_Call{Call: _e.mock.On("GetVG", ctx, name)}
}

func (_c *MockLVM_GetVG_Call) Run(run func(ctx context.Context, name string)) *MockLVM_GetVG_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLVM_GetVG_Call) Return(_a0 lvm.VolumeGroup, _a1 error) *MockLVM_GetVG_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLVM_GetVG_Call) RunAndReturn(run func(context.Context, string) (lvm.VolumeGroup, error)) *MockLVM_GetVG_Call {
	_c.Call.Return(run)
	return _c
}

// LVExists provides a mock function with given fields: ctx, lvName, vgName
func (_m *MockLVM) LVExists(ctx context.Context, lvName string, vgName string) (bool, error) {
	ret := _m.Called(ctx, lvName, vgName)

	if len(ret) == 0 {
		panic("no return value specified for LVExists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return rf(ctx, lvName, vgName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = rf(ctx, lvName, vgName)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, lvName, vgName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLVM_LVExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LVExists'
type MockLVM_LVExists_Call struct {
	*mock.Call
}

// LVExists is a helper method to define mock.On call
//   - ctx context.Context
//   - lvName string
//   - vgName string
func (_e *MockLVM_Expecter) LVExists(ctx interface{}, lvName interface{}, vgName interface{}) *MockLVM_LVExists_Call {
	return &MockLVM_LVExists_Call{Call: _e.mock.On("LVExists", ctx, lvName, vgName)}
}

func (_c *MockLVM_LVExists_Call) Run(run func(ctx context.Context, lvName string, vgName string)) *MockLVM_LVExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockLVM_LVExists_Call) Return(_a0 bool, _a1 error) *MockLVM_LVExists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLVM_LVExists_Call) RunAndReturn(run func(context.Context, string, string) (bool, error)) *MockLVM_LVExists_Call {
	_c.Call.Return(run)
	return _c
}

// ListLVs provides a mock function with given fields: ctx, vgName
func (_m *MockLVM) ListLVs(ctx context.Context, vgName string) (*lvm.LVReport, error) {
	ret := _m.Called(ctx, vgName)

	if len(ret) == 0 {
		panic("no return value specified for ListLVs")
	}

	var r0 *lvm.LVReport
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*lvm.LVReport, error)); ok {
		return rf(ctx, vgName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *lvm.LVReport); ok {
		r0 = rf(ctx, vgName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lvm.LVReport)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, vgName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLVM_ListLVs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListLVs'
type MockLVM_ListLVs_Call struct {
	*mock.Call
}

// ListLVs is a helper method to define mock.On call
//   - ctx context.Context
//   - vgName string
func (_e *MockLVM_Expecter) ListLVs(ctx interface{}, vgName interface{}) *MockLVM_ListLVs_Call {
	return &MockLVM_ListLVs_Call{Call: _e.mock.On("ListLVs", ctx, vgName)}
}

func (_c *MockLVM_ListLVs_Call) Run(run func(ctx context.Context, vgName string)) *MockLVM_ListLVs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLVM_ListLVs_Call) Return(_a0 *lvm.LVReport, _a1 error) *MockLVM_ListLVs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLVM_ListLVs_Call) RunAndReturn(run func(context.Context, string) (*lvm.LVReport, error)) *MockLVM_ListLVs_Call {
	_c.Call.Return(run)
	return _c
}

// ListLVsByName provides a mock function with given fields: ctx, vgName
func (_m *MockLVM) ListLVsByName(ctx context.Context, vgName string) ([]string, error) {
	ret := _m.Called(ctx, vgName)

	if len(ret) == 0 {
		panic("no return value specified for ListLVsByName")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]string, error)); ok {
		return rf(ctx, vgName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []string); ok {
		r0 = rf(ctx, vgName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, vgName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLVM_ListLVsByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListLVsByName'
type MockLVM_ListLVsByName_Call struct {
	*mock.Call
}

// ListLVsByName is a helper method to define mock.On call
//   - ctx context.Context
//   - vgName string
func (_e *MockLVM_Expecter) ListLVsByName(ctx interface{}, vgName interface{}) *MockLVM_ListLVsByName_Call {
	return &MockLVM_ListLVsByName_Call{Call: _e.mock.On("ListLVsByName", ctx, vgName)}
}

func (_c *MockLVM_ListLVsByName_Call) Run(run func(ctx context.Context, vgName string)) *MockLVM_ListLVsByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLVM_ListLVsByName_Call) Return(_a0 []string, _a1 error) *MockLVM_ListLVsByName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLVM_ListLVsByName_Call) RunAndReturn(run func(context.Context, string) ([]string, error)) *MockLVM_ListLVsByName_Call {
	_c.Call.Return(run)
	return _c
}

// ListPVs provides a mock function with given fields: ctx, vgName
func (_m *MockLVM) ListPVs(ctx context.Context, vgName string) ([]lvm.PhysicalVolume, error) {
	ret := _m.Called(ctx, vgName)

	if len(ret) == 0 {
		panic("no return value specified for ListPVs")
	}

	var r0 []lvm.PhysicalVolume
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]lvm.PhysicalVolume, error)); ok {
		return rf(ctx, vgName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []lvm.PhysicalVolume); ok {
		r0 = rf(ctx, vgName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]lvm.PhysicalVolume)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, vgName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLVM_ListPVs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPVs'
type MockLVM_ListPVs_Call struct {
	*mock.Call
}

// ListPVs is a helper method to define mock.On call
//   - ctx context.Context
//   - vgName string
func (_e *MockLVM_Expecter) ListPVs(ctx interface{}, vgName interface{}) *MockLVM_ListPVs_Call {
	return &MockLVM_ListPVs_Call{Call: _e.mock.On("ListPVs", ctx, vgName)}
}

func (_c *MockLVM_ListPVs_Call) Run(run func(ctx context.Context, vgName string)) *MockLVM_ListPVs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLVM_ListPVs_Call) Return(_a0 []lvm.PhysicalVolume, _a1 error) *MockLVM_ListPVs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLVM_ListPVs_Call) RunAndReturn(run func(context.Context, string) ([]lvm.PhysicalVolume, error)) *MockLVM_ListPVs_Call {
	_c.Call.Return(run)
	return _c
}

// ListVGs provides a mock function with given fields: ctx, taggedByLVMS, opts
func (_m *MockLVM) ListVGs(ctx context.Context, taggedByLVMS bool, opts lvm.ListVGOptions) ([]lvm.VolumeGroup, error) {
	ret := _m.Called(ctx, taggedByLVMS, opts)

	if len(ret) == 0 {
		panic("no return value specified for ListVGs")
	}

	var r0 []lvm.VolumeGroup
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, bool, lvm.ListVGOptions) ([]lvm.VolumeGroup, error)); ok {
		return rf(ctx, taggedByLVMS, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, bool, lvm.ListVGOptions) []lvm.VolumeGroup); ok {
		r0 = rf(ctx, taggedByLVMS, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]lvm.VolumeGroup)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, bool, lvm.ListVGOptions) error); ok {
		r1 = rf(ctx, taggedByLVMS, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLVM_ListVGs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListVGs'
type MockLVM_ListVGs_Call struct {
	*mock.Call
}

// ListVGs is a helper method to define mock.On call
//   - ctx context.Context
//   - taggedByLVMS bool
//   - opts lvm.ListVGOptions
func (_e *MockLVM_Expecter) ListVGs(ctx interface{}, taggedByLVMS interface{}, opts interface{}) *MockLVM_ListVGs_Call {
	return &MockLVM_ListVGs_Call{Call: _e.mock.On("ListVGs", ctx, taggedByLVMS, opts)}
}

func (_c *MockLVM_ListVGs_Call) Run(run func(ctx context.Context, taggedByLVMS bool, opts lvm.ListVGOptions)) *MockLVM_ListVGs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(bool), args[2].(lvm.ListVGOptions))
	})
	return _c
}

func (_c *MockLVM_ListVGs_Call) Return(_a0 []lvm.VolumeGroup, _a1 error) *MockLVM_ListVGs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLVM_ListVGs_Call) RunAndReturn(run func(context.Context, bool, lvm.ListVGOptions) ([]lvm.VolumeGroup, error)) *MockLVM_ListVGs_Call {
	_c.Call.Return(run)
	return _c
}

// LockStart provides a mock function with given fields: ctx, vgName
func (_m *MockLVM) LockStart(ctx context.Context, vgName string) error {
	ret := _m.Called(ctx, vgName)

	if len(ret) == 0 {
		panic("no return value specified for LockStart")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, vgName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLVM_LockStart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LockStart'
type MockLVM_LockStart_Call struct {
	*mock.Call
}

// LockStart is a helper method to define mock.On call
//   - ctx context.Context
//   - vgName string
func (_e *MockLVM_Expecter) LockStart(ctx interface{}, vgName interface{}) *MockLVM_LockStart_Call {
	return &MockLVM_LockStart_Call{Call: _e.mock.On("LockStart", ctx, vgName)}
}

func (_c *MockLVM_LockStart_Call) Run(run func(ctx context.Context, vgName string)) *MockLVM_LockStart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLVM_LockStart_Call) Return(_a0 error) *MockLVM_LockStart_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLVM_LockStart_Call) RunAndReturn(run func(context.Context, string) error) *MockLVM_LockStart_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLVM creates a new instance of MockLVM. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLVM(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLVM {
	mock := &MockLVM{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
